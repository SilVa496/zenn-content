---
title: "Rustã§MultiSetã‚’å®Ÿè£…ã™ã‚‹"
emoji: "ğŸ—ƒï¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "atcoder", "ãƒ‡ãƒ¼ã‚¿æ§‹é€ ", "multiset"]
published: true
---

# TL;DR
- BTreeMapã‚’ãƒ™ãƒ¼ã‚¹ã«Rustã§ãƒãƒ«ãƒã‚»ãƒƒãƒˆã‚’ä½œã‚Šã¾ã—ãŸ
- C++ã«ã‚ã‚‹[MultiSet](https://cpprefjp.github.io/reference/set/multiset.html)ã¨ã ã„ãŸã„åŒã˜ã“ã¨ãŒã§ãã¾ã™
- ~~ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“~~ (è¿½è¨˜ï¼šå®Ÿè£…ã—ã¾ã—ãŸ)

ä½¿ã£ãŸå ±å‘Šã‚’ã—ã¦ãã‚Œã‚‹ã¨åƒ•ãŒæ³£ã„ã¦å–œã³ã¾ã™ã€‚

# ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³
AtCoderã‚’æœ€è¿‘ã¯é ‘å¼µã£ã¦ã‚„ã£ã¦ã‚‹ã‚“ã§ã™ãŒã€[ABC308F: Vouchers](https://atcoder.jp/contests/abc308/tasks/abc308_f)ãªã©ã®å•é¡Œã§`MultiSet`ãŒæ¬²ã—ã„ãªã€œã¿ãŸã„ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒã¡ã‚‡ã“ã¡ã‚‡ã“ã‚ã‚Šã¾ã™ã€‚â€`MultiSet`ãŒãªã„ã®ã§ã€å®Ÿè£…ãã¤ã„ã§ã™â€ã¯è‰¯ããªã„ã®ã§ã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆä¸­ã«ä½¿ãˆã‚‹ã‚ˆã†ã«å‡¦ç†ã‚’ã¾ã¨ã‚ã‚ˆã†ï¼ã¨ã„ã†ã“ã¨ã§æ›¸ãã¾ã—ãŸã€‚

# MultiSetã¨ã¯ï¼Ÿ
MultiSetã¯æ•°å­¦ã«ãŠã‘ã‚‹å¤šé‡é›†åˆã«å¯¾å¿œã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚æ™®é€šã€é›†åˆã¨ã„ãˆã°è¦ç´ ã®é‡è¤‡ãŒè¨±ã•ã‚Œã¾ã›ã‚“ãŒã€å¤šé‡é›†åˆã¯é‡è¤‡ã‚’è¨±ã—ã¾ã™ã€‚ã‚¤ãƒ¡ãƒ¼ã‚¸ã¨ã—ã¦ã¯ã€é †åºã®ãªã„æ•°åˆ—ã®ã‚ˆã†ãªæ„Ÿã˜ã§ã™ã€‚

ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã‚‚ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ãŒã€C++ãã‚‰ã„ã§ã—ã‹æ¨™æº–ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã®ã‚’å¯¡èã«ã—ã¦èã„ãŸã“ã¨ãŒãªã„ã®ã§ã€`Python`å‹¢ã‚„`Rust`å‹¢ã®ã¿ãªã•ã‚“ã©ã†ã‚„ã£ã¦é€šã—ã¦ã‚‹ã‚“ã§ã—ã‚‡ã†ã‹...ï¼Ÿ

# å®Ÿè£…

BTreeMapã«é‡è¤‡ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚å€¤ã‚’æŒ¿å…¥ã™ã‚‹ã¨ã€BTreeMapä¸Šã®ã‚«ã‚¦ãƒ³ãƒˆã‚’1å¢—ã‚„ã™ã€BTreeMapä¸Šã®ã‚«ã‚¦ãƒ³ãƒˆãŒ0ã«ãªã£ãŸã‚‰keyã‚’æ¶ˆã™ã¨ã„ã†å˜ç´”ãªæ–¹æ³•ã§ã™ã€‚

æ™®é€š`MultiSet`ã¨ã„ãˆã°ã€èµ¤é»’æœ¨ãªã©ã®å¹³è¡äºŒåˆ†æœ¨ã‚’ç”¨ã„ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚BTreeMapã§ã®å®Ÿè£…ã¯é‡è¤‡ãŒå¤§é‡ã«ã‚ã‚‹å ´åˆæœ‰åˆ©ã§ã™ãŒã€å¤šãã®å ´åˆã«ãŠã„ã¦ã¯å¹³è¡äºŒåˆ†æœ¨ã®ã»ã†ãŒè‰¯ã„ã¨æ€ã„ã¾ã™ï¼ˆæœªæ¤œè¨¼ï¼‰ã€‚

~~ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å®Ÿè£…ã¯ã„ã„æ„Ÿã˜ã«ç§ã®æŠ€é‡ã§ã¯ã§ããªã‹ã£ãŸã®ã§ã€ä»Šå›ã¯å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“ã€‚å˜ã«ã€é‡è¤‡ã‚’å‰Šé™¤ã—ãŸã‚‚ã®ã‚’è¿”ã—ã¦ã‚‚è‰¯ã‹ã£ãŸã‚“ã§ã™ãŒã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã˜ã‚ƒãªã„ã‚ˆãªãƒ¼ã¨æ€ã£ãŸã®ã§ãã®ã¾ã¾ã§ã™ã€‚~~

ã„ã„æ„Ÿã˜ã«å®Ÿè£…ã§ããŸã®ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚‚å®Ÿè£…ã—ã¾ã—ãŸã€‚

BTreeMapã‚’ä½¿ã†ã®ã§**Ordãƒˆãƒ¬ã‚¤ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™**ã€‚

ã‚³ãƒ¼ãƒ‰ã¯é•·ã„ã®ã§æŠ˜ã‚ŠãŸãŸã¿

:::details ã‚³ãƒ¼ãƒ‰
```rust
#[allow(dead_code)]
mod procon_lib {
    use std::{
        borrow::Borrow,
        collections::{
            btree_map::{self},
            BTreeMap,
        },
        ops::{Bound, RangeBounds},
    };

    #[derive(Debug, PartialEq, Clone)]
    pub struct MultiSet<T> {
        size: usize,
        btree_map: BTreeMap<T, usize>,
    }

    impl<T: Ord> Default for MultiSet<T> {
        fn default() -> Self {
            Self::new()
        }
    }

    impl<T: Ord> From<Vec<T>> for MultiSet<T> {
        fn from(value: Vec<T>) -> Self {
            let size = value.len();

            let mut btree_map = BTreeMap::default();
            for key in value {
                *btree_map.entry(key).or_insert(0) += 1;
            }

            Self { size, btree_map }
        }
    }

    impl<T: Ord> MultiSet<T> {
        pub fn clear(&mut self) {
            self.size = 0;
            self.btree_map.clear();
        }

        pub fn contains<Q>(&self, value: &Q) -> bool
        where
            T: Borrow<Q>,
            Q: Ord + ?Sized,
        {
            self.btree_map.contains_key(value)
        }

        pub fn insert(&mut self, value: T) {
            self.size += 1;
            *self.btree_map.entry(value).or_insert(0) += 1;
        }

        pub fn first(&self) -> Option<&T> {
            if let Some((key, _)) = self.btree_map.iter().next() {
                Some(key)
            } else {
                None
            }
        }

        pub fn last(&self) -> Option<&T> {
            if let Some((key, _)) = self.btree_map.iter().next_back() {
                Some(key)
            } else {
                None
            }
        }

        pub fn is_empty(&self) -> bool {
            self.btree_map.is_empty()
        }

        pub fn len(&self) -> usize {
            self.btree_map.len()
        }

        pub fn size(&self) -> usize {
            self.size
        }

        pub fn marge(&mut self, other: &mut MultiSet<T>)
        where
            T: Clone,
        {
            self.size += other.size;

            for (key, val) in other.btree_map.iter() {
                if let Some(prev) = self.btree_map.get_mut(key) {
                    *prev += *val;
                } else {
                    self.btree_map.insert(key.clone(), *val);
                }
            }
        }

        pub fn new() -> Self {
            Self {
                size: 0,
                btree_map: BTreeMap::new(),
            }
        }

        pub fn pop_first(&mut self) -> Option<T>
        where
            T: Clone,
        {
            if self.is_empty() {
                None
            } else {
                self.size -= 1;

                let first = self.first().unwrap().clone();
                self.remove(&first);
                Some(first)
            }
        }

        pub fn pop_last(&mut self) -> Option<T>
        where
            T: Clone,
        {
            if self.is_empty() {
                None
            } else {
                self.size -= 1;

                let last = self.last().unwrap().clone();
                self.remove(&last);
                Some(last)
            }
        }

        pub fn remove(&mut self, value: &T) -> bool
        where
            T: Clone,
        {
            self.btree_map.entry(value.clone()).and_modify(|e| *e -= 1);
            if let Some(&cnt) = self.btree_map.get(&value) {
                if cnt == 0 {
                    self.btree_map.remove(&value);
                }

                self.size -= 1;
                true
            } else {
                false
            }
        }

        pub fn lower_bound<Q>(&self, bound: Bound<&Q>) -> Option<&T>
        where
            T: Borrow<Q>,
            Q: Ord,
        {
            match bound {
                Bound::Unbounded => unreachable!(),
                _ => {
                    if let Some((key, _)) = self.btree_map.range((bound, Bound::Unbounded)).next() {
                        Some(key)
                    } else {
                        None
                    }
                }
            }
        }

        pub fn upper_bound<Q>(&self, bound: Bound<&Q>) -> Option<&T>
        where
            T: Borrow<Q>,
            Q: Ord,
        {
            match bound {
                Bound::Unbounded => unreachable!(),
                _ => {
                    if let Some((key, _)) =
                        self.btree_map.range((Bound::Unbounded, bound)).next_back()
                    {
                        Some(key)
                    } else {
                        None
                    }
                }
            }
        }

        pub fn iter(&self) -> Iter<'_, T> {
            Iter {
                range: self.range(..),
            }
        }

        pub fn range<U: ?Sized, R>(&self, range: R) -> Range<'_, T>
        where
            U: Ord,
            T: Borrow<U> + Ord,
            R: RangeBounds<U>,
        {
            Range {
                last: None,
                counter: 0,
                range: self.btree_map.range(range),
            }
        }

        pub fn count<Q>(&self, value: &Q) -> usize
        where
            T: Borrow<Q>,
            Q: Ord,
        {
            if let Some(&cnt) = self.btree_map.get(value) {
                cnt
            } else {
                0
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Range<'a, T>
    where
        T: 'a,
    {
        last: Option<&'a T>,
        counter: usize,
        range: btree_map::Range<'a, T, usize>,
    }

    impl<'a, T> Iterator for Range<'a, T> {
        type Item = &'a T;
        fn next(&mut self) -> Option<Self::Item> {
            if self.counter == 0 {
                if let Some((elem, &cnt)) = self.range.next() {
                    self.last = Some(elem);
                    self.counter = cnt - 1;
                    Some(elem)
                } else {
                    None
                }
            } else {
                self.counter -= 1;
                self.last
            }
        }
    }

    impl<'a, T> DoubleEndedIterator for Range<'a, T> {
        fn next_back(&mut self) -> Option<Self::Item> {
            if self.counter == 0 {
                if let Some((elem, &cnt)) = self.range.next_back() {
                    self.last = Some(elem);
                    self.counter = cnt;
                    Some(elem)
                } else {
                    None
                }
            } else {
                self.counter -= 1;
                self.last
            }
        }
    }

    #[derive(Clone, Debug, Default)]
    pub struct Iter<'a, T>
    where
        T: 'a,
    {
        range: Range<'a, T>,
    }

    impl<'a, T> Iterator for Iter<'a, T> {
        type Item = &'a T;
        fn next(&mut self) -> Option<Self::Item> {
            self.range.next()
        }
    }

    impl<'a, T> DoubleEndedIterator for Iter<'a, T> {
        fn next_back(&mut self) -> Option<Self::Item> {
            self.range.next_back()
        }
    }
}

```
:::

# æ©Ÿèƒ½ã¨ä½¿ã„æ–¹
## `new()`, `default()`
ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã©ã¡ã‚‰ã‚‚ç­‰ä¾¡ã§ã™ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    // ã©ã¡ã‚‰ã§ã‚‚ã„ã£ã—ã‚‡
    let multiset = MultiSet::new();
    let multiset = MultiSet::default();
}
```

## `from(Vec<T>)`
`Vec<T>`ã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let multiset = MultiSet::from(vec![1, 1, 2, 3]);
}
```


## `clear()`
`MultiSet`ã‚’ç©ºé›†åˆã«ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 2, 3]);

    a.clear();
    assert_eq!(a, MultiSet::from(vec![]));
}
```

## `contains(&T)`
`MultiSet`ãŒå¼•æ•°ã‚’å…ƒã¨ã—ã¦å«ã‚€ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 2, 2, 3]);

    assert_eq!(a.contains(&1), true);
    assert_eq!(a.contains(&0), false);
}
```

## `insert(T)`
`MultiSet`ã«å¼•æ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 2, 2, 3]);

    a.insert(0);
    assert_eq!(a, MultiSet::from(vec![0, 1, 2, 2, 3]));
}
```

## `first()`, `last()`
`first`ã¯æœ€å°ã®è¦ç´ ã‚’ã€`last()`ã¯æœ€å¤§ã®è¦ç´ ã‚’å–å¾—ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.first(), Some(&1));
    assert_eq!(a.last(), Some(&3));
}
```

## `pop_first`, `pop_last()`
`pop_first()`ã¯æœ€å°ã®è¦ç´ ã‚’ã€`pop_last()`ã¯æœ€å¤§ã®è¦ç´ ã‚’1ã¤å‰Šé™¤ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.pop_first(), Some(1));
    assert_eq!(a, MultiSet::from(vec![1, 2, 2, 3]));

    assert_eq!(a.pop_last(), Some(3));
    assert_eq!(a, MultiSet::from(vec![1, 2, 2]));
}
```

## `is_empty()`, `len()`, `size()`
`is_empty()`ã¯ç©ºé›†åˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚`len()`ã¯é›†åˆã®å…ƒã®ç¨®é¡ã‚’è¿”ã™ä¸€æ–¹ã€`size()`ã¯å…ƒã®å€‹æ•°ã‚’è¿”ã—ã¾ã™ï¼ˆå‘½åãŒæ€ªã—ã„ï¼‰ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.is_empty(), false);
    assert_eq!(a.len(), 3);
    assert_eq!(a.size(), 5);
}
```

## `count(&Q)`
å¼•æ•°ã®è¦ç´ ãŒé›†åˆå†…ã«ã„ãã¤ã‚ã‚‹ã®ã‹ã‚’è¿”ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.count(&2), 2);
}
```

## `remove(&T)`
`MultiSet`ã‹ã‚‰å¼•æ•°ã®å…ƒã‚’ä¸€ã¤å‰Šé™¤ã—ã¾ã™ã€‚å‰Šé™¤ã«æˆåŠŸã™ã‚Œã°`true`ã‚’ã€å‰Šé™¤ã§ããªã‘ã‚Œã°`false`ã‚’è¿”ã—ã¾ã™ã€‚

```rust
fn main() {
    let mut a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.remove(&2), true);
    assert_eq!(a.remove(&4), false);

    assert_eq!(a, MultiSet::from(vec![1, 1, 2, 3]));
}
```

## `lower_bound(Bound<&Q>)`
`std::ops::Bound`ã‚’å¼•æ•°ã«ã¨ã‚Šã€å¼•æ•°ã‚ˆã‚Šã‚‚å¤§ãã„ã€ã¾ãŸã¯å¼•æ•°ä»¥ä¸Šã®ã‚‚ã®ã®ä¸­ã‹ã‚‰æœ€å°ã®ã‚‚ã®ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.lower_bound(std::ops::Bound::Included(&0)), Some(&1));
    assert_eq!(a.lower_bound(std::ops::Bound::Included(&2)), Some(&2));
    assert_eq!(a.lower_bound(std::ops::Bound::Excluded(&2)), Some(&3));
    assert_eq!(a.lower_bound(std::ops::Bound::Excluded(&4)), None);
}
```

## `upper_bound(Bound<&Q>)`
`std::ops::Bound`ã‚’å¼•æ•°ã«ã¨ã‚Šã€å¼•æ•°ã‚ˆã‚Šã‚‚å°ã•ã„ã€ã¾ãŸã¯å¼•æ•°ä»¥ä¸‹ã®ã‚‚ã®ã®ä¸­ã‹ã‚‰æœ€å¤§ã®ã‚‚ã®ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.upper_bound(std::ops::Bound::Excluded(&0)), None);
    assert_eq!(a.upper_bound(std::ops::Bound::Excluded(&2)), Some(&1));
    assert_eq!(a.upper_bound(std::ops::Bound::Included(&2)), Some(&2));
    assert_eq!(a.upper_bound(std::ops::Bound::Included(&4)), Some(&3));
}
```

## `iter()`
å‚ç…§ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    let mut b = vec![];
    for &e in a.iter() {
        b.push(e);
    }

    assert_eq!(b, vec![1, 1, 2, 2, 3]);
    assert_eq!(a, MultiSet::from(b));
}
```

## `range(..)`
å¼•æ•°ã®ç¯„å›²ã«ã‚ã‚‹è¦ç´ ã®å‚ç…§ã®Iterableã‚’è¿”ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 2, 3, 4, 4, 5, 6, 7, 8]);

    let mut b = vec![];
    for &e in a.range(2..=5) {
        b.push(e);
    }

    assert_eq!(b, vec![2, 3, 4, 4, 5]);
}
```

## `marge`
ç‰‡æ–¹ã®`MultiSet`ã‚’ã‚‚ã†ç‰‡æ–¹ã«ãƒãƒ¼ã‚¸ã—ã¦ã€å’Œé›†åˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 2, 3]);
    let mut b = MultiSet::from(vec![1, 1, 2, 3]);
    
    a.marge(&mut b);
    assert_eq!(a, MultiSet::from(vec![1, 1, 1, 2, 2, 3, 3]));
}
```


# ä½¿ç”¨ä¾‹

- [AtCoder Beginner Contest 308: F - Vouchers](https://atcoder.jp/contests/abc308/submissions/43210074)
- [AtCoder Beginner Contest 253: C - Max - Min Query](https://atcoder.jp/contests/abc253/submissions/43210678)
- [AtCoder Beginner Contest 170: E - Smart Infants](https://atcoder.jp/contests/abc170/submissions/43213745)