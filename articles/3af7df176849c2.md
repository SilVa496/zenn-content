---
title: "Rustã§MultiSetã‚’å®Ÿè£…ã™ã‚‹"
emoji: "ğŸ—ƒï¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "ãƒ‡ãƒ¼ã‚¿æ§‹é€ ", "multiset"]
published: true
---

# TL;DR
- BTreeMapã‚’ãƒ™ãƒ¼ã‚¹ã«Rustã§ãƒãƒ«ãƒã‚»ãƒƒãƒˆã‚’ä½œã‚Šã¾ã—ãŸ
- C++ã«ã‚ã‚‹[MultiSet](https://cpprefjp.github.io/reference/set/multiset.html)ã¨ã ã„ãŸã„åŒã˜ã“ã¨ãŒã§ãã¾ã™
- ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“

ä½¿ã£ãŸå ±å‘Šã‚’ã—ã¦ãã‚Œã‚‹ã¨åƒ•ãŒæ³£ã„ã¦å–œã³ã¾ã™ã€‚

# ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³
AtCoderã‚’æœ€è¿‘ã¯é ‘å¼µã£ã¦ã‚„ã£ã¦ã‚‹ã‚“ã§ã™ãŒã€[Vouchers](https://atcoder.jp/contests/abc308/tasks/abc308_f)ãªã©ã®å•é¡Œã§`MultiSet`ãŒæ¬²ã—ã„ãªã€œã¿ãŸã„ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒã¡ã‚‡ã“ã¡ã‚‡ã“ã‚ã‚Šã¾ã™ã€‚â€`MultiSet`ãŒãªã„ã®ã§ã€å®Ÿè£…ãã¤ã„ã§ã™â€ã¯è‰¯ããªã„ã®ã§ã€ã‚³ãƒ³ãƒ†ã‚¹ãƒˆä¸­ã«ä½¿ãˆã‚‹ã‚ˆã†ã«å‡¦ç†ã‚’ã¾ã¨ã‚ã‚ˆã†ï¼ã¨ã„ã†ã“ã¨ã§æ›¸ãã¾ã—ãŸã€‚

# å®Ÿè£…

BTreeMapã«é‡è¤‡ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚å€¤ã‚’æŒ¿å…¥ã™ã‚‹ã¨ã€BTreeMapä¸Šã®ã‚«ã‚¦ãƒ³ãƒˆã‚’1å¢—ã‚„ã™ã€BTreeMapä¸Šã®ã‚«ã‚¦ãƒ³ãƒˆãŒ0ã«ãªã£ãŸã‚‰keyã‚’æ¶ˆã™ã¨ã„ã†å˜ç´”ãªæ–¹æ³•ã§ã™ã€‚

ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å®Ÿè£…ã¯ã„ã„æ„Ÿã˜ã«ç§ã®æŠ€é‡ã§ã¯ã§ããªã‹ã£ãŸã®ã§ã€ä»Šå›ã¯å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“ã€‚å˜ã«ã€é‡è¤‡ã‚’å‰Šé™¤ã—ãŸã‚‚ã®ã‚’è¿”ã—ã¦ã‚‚è‰¯ã‹ã£ãŸã‚“ã§ã™ãŒã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã˜ã‚ƒãªã„ã‚ˆãªãƒ¼ã¨æ€ã£ãŸã®ã§ãã®ã¾ã¾ã§ã™ã€‚

BTreeMapã‚’ä½¿ã†ã®ã§**Ordãƒˆãƒ¬ã‚¤ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™**ã€‚

ã‚³ãƒ¼ãƒ‰ã¯é•·ã„ã®ã§æŠ˜ã‚ŠãŸãŸã¿

:::details ã‚³ãƒ¼ãƒ‰
```rust
#[allow(dead_code)]
mod procon_lib {
    use std::{borrow::Borrow, collections::BTreeMap, ops::Bound};

    #[derive(Debug, PartialEq, Clone)]
    pub struct MultiSet<T> {
        size: usize,
        btree_map: BTreeMap<T, usize>,
    }

    impl<T: Ord> Default for MultiSet<T> {
        fn default() -> Self {
            Self::new()
        }
    }

    impl<T: Ord> From<Vec<T>> for MultiSet<T> {
        fn from(value: Vec<T>) -> Self {
            let size = value.len();

            let mut btree_map = BTreeMap::default();
            for key in value {
                *btree_map.entry(key).or_insert(0) += 1;
            }

            Self { size, btree_map }
        }
    }

    impl<T: Ord> MultiSet<T> {
        pub fn clear(&mut self) {
            self.size = 0;
            self.btree_map.clear();
        }

        pub fn contains<Q>(&self, value: &Q) -> bool
        where
            T: Borrow<Q>,
            Q: Ord + ?Sized,
        {
            self.btree_map.contains_key(value)
        }

        pub fn insert(&mut self, value: T) {
            self.size += 1;
            *self.btree_map.entry(value).or_insert(0) += 1;
        }

        pub fn first(&self) -> Option<&T> {
            if let Some((key, _)) = self.btree_map.iter().next() {
                Some(key)
            } else {
                None
            }
        }

        pub fn last(&self) -> Option<&T> {
            if let Some((key, _)) = self.btree_map.iter().next_back() {
                Some(key)
            } else {
                None
            }
        }

        pub fn is_empty(&self) -> bool {
            self.btree_map.is_empty()
        }

        pub fn len(&self) -> usize {
            self.btree_map.len()
        }

        pub fn size(&self) -> usize {
            self.size
        }

        pub fn marge(&mut self, other: &mut MultiSet<T>)
        where
            T: Clone,
        {
            self.size += other.size;

            for (key, val) in other.btree_map.iter() {
                if let Some(prev) = self.btree_map.get_mut(key) {
                    *prev += *val;
                } else {
                    self.btree_map.insert(key.clone(), *val);
                }
            }
        }

        pub fn new() -> Self {
            Self {
                size: 0,
                btree_map: BTreeMap::new(),
            }
        }

        pub fn pop_first(&mut self) -> Option<T>
        where
            T: Clone,
        {
            if self.is_empty() {
                None
            } else {
                self.size -= 1;

                let first = self.first().unwrap().clone();
                self.remove(&first);
                Some(first)
            }
        }

        pub fn pop_last(&mut self) -> Option<T>
        where
            T: Clone,
        {
            if self.is_empty() {
                None
            } else {
                self.size -= 1;

                let last = self.last().unwrap().clone();
                self.remove(&last);
                Some(last)
            }
        }

        pub fn remove(&mut self, value: &T) -> bool
        where
            T: Clone,
        {
            self.btree_map.entry(value.clone()).and_modify(|e| *e -= 1);
            if let Some(&cnt) = self.btree_map.get(&value) {
                if cnt == 0 {
                    self.btree_map.remove(&value);
                }

                self.size -= 1;
                true
            } else {
                false
            }
        }

        pub fn lower_bound<Q>(&self, bound: Bound<&Q>) -> Option<&T>
        where
            T: Borrow<Q>,
            Q: Ord,
        {
            match bound {
                Bound::Unbounded => unreachable!(),
                _ => {
                    if let Some((key, _)) = self.btree_map.range((bound, Bound::Unbounded)).next() {
                        Some(key)
                    } else {
                        None
                    }
                }
            }
        }

        pub fn upper_bound<Q>(&self, bound: Bound<&Q>) -> Option<&T>
        where
            T: Borrow<Q>,
            Q: Ord,
        {
            match bound {
                Bound::Unbounded => unreachable!(),
                _ => {
                    if let Some((key, _)) =
                        self.btree_map.range((Bound::Unbounded, bound)).next_back()
                    {
                        Some(key)
                    } else {
                        None
                    }
                }
            }
        }

        pub fn count<Q>(&self, value: &Q) -> usize
        where
            T: Borrow<Q>,
            Q: Ord,
        {
            if let Some(&cnt) = self.btree_map.get(value) {
                cnt
            } else {
                0
            }
        }
    }
}
```
:::

# æ©Ÿèƒ½ã¨ä½¿ã„æ–¹
## `new()`, `default()`
ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã©ã¡ã‚‰ã‚‚ç­‰ä¾¡ã§ã™ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    // ã©ã¡ã‚‰ã§ã‚‚ã„ã£ã—ã‚‡
    let multiset = MultiSet::new();
    let multiset = MultiSet::default();
}
```

## `from(Vec<T>)`
`Vec<T>`ã‹ã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let multiset = MultiSet::from(vec![1, 1, 2, 3]);
}
```


## `clear()`
`MultiSet`ã‚’ç©ºé›†åˆã«ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 2, 3]);

    a.clear();
    assert_eq!(a, MultiSet::from(vec![]));
}
```

## `contains(&T)`
`MultiSet`ãŒå¼•æ•°ã‚’å…ƒã¨ã—ã¦å«ã‚€ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 2, 2, 3]);

    assert_eq!(a.contains(&1), true);
    assert_eq!(a.contains(&0), false);
}
```

## `insert(T)`
`MultiSet`ã«å¼•æ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 2, 2, 3]);

    a.insert(0);
    assert_eq!(a, MultiSet::from(vec![0, 1, 2, 2, 3]));
}
```

## `first()`, `last()`
`first`ã¯æœ€å°ã®è¦ç´ ã‚’ã€`last()`ã¯æœ€å¤§ã®è¦ç´ ã‚’å–å¾—ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.first(), Some(&1));
    assert_eq!(a.last(), Some(&3));
}
```

## `pop_first`, `pop_last()`
`pop_first()`ã¯æœ€å°ã®è¦ç´ ã‚’ã€`pop_last()`ã¯æœ€å¤§ã®è¦ç´ ã‚’1ã¤å‰Šé™¤ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.pop_first(), Some(1));
    assert_eq!(a, MultiSet::from(vec![1, 2, 2, 3]));

    assert_eq!(a.pop_last(), Some(3));
    assert_eq!(a, MultiSet::from(vec![1, 2, 2]));
}
```

## `is_empty()`, `len()`, `size()`
`is_empty()`ã¯ç©ºé›†åˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚`len()`ã¯é›†åˆã®å…ƒã®ç¨®é¡ã‚’è¿”ã™ä¸€æ–¹ã€`size()`ã¯å…ƒã®å€‹æ•°ã‚’è¿”ã—ã¾ã™ï¼ˆå‘½åãŒæ€ªã—ã„ï¼‰ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.is_empty(), false);
    assert_eq!(a.len(), 3);
    assert_eq!(a.size(), 5);
}
```

## `count(&Q)`
å¼•æ•°ã®è¦ç´ ãŒé›†åˆå†…ã«ã„ãã¤ã‚ã‚‹ã®ã‹ã‚’è¿”ã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.count(&2), 2);
}
```

## `remove(&T)`
`MultiSet`ã‹ã‚‰å¼•æ•°ã®å…ƒã‚’ä¸€ã¤å‰Šé™¤ã—ã¾ã™ã€‚å‰Šé™¤ã«æˆåŠŸã™ã‚Œã°`true`ã‚’ã€å‰Šé™¤ã§ããªã‘ã‚Œã°`false`ã‚’è¿”ã—ã¾ã™ã€‚

```rust
fn main() {
    let mut a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.remove(&2), true);
    assert_eq!(a.remove(&4), false);

    assert_eq!(a, MultiSet::from(vec![1, 1, 2, 3]));
}
```

## `lower_bound(Bound<&Q>)`
`std::ops::Bound`ã‚’å¼•æ•°ã«ã¨ã‚Šã€å¼•æ•°ã‚ˆã‚Šã‚‚å¤§ãã„ã€ã¾ãŸã¯å¼•æ•°ä»¥ä¸Šã®ã‚‚ã®ã®ä¸­ã‹ã‚‰æœ€å°ã®ã‚‚ã®ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.lower_bound(std::ops::Bound::Included(&0)), Some(&1));
    assert_eq!(a.lower_bound(std::ops::Bound::Included(&2)), Some(&2));
    assert_eq!(a.lower_bound(std::ops::Bound::Excluded(&2)), Some(&3));
    assert_eq!(a.lower_bound(std::ops::Bound::Excluded(&4)), None);
}
```

## `upper_bound(Bound<&Q>)`
`std::ops::Bound`ã‚’å¼•æ•°ã«ã¨ã‚Šã€å¼•æ•°ã‚ˆã‚Šã‚‚å°ã•ã„ã€ã¾ãŸã¯å¼•æ•°ä»¥ä¸‹ã®ã‚‚ã®ã®ä¸­ã‹ã‚‰æœ€å¤§ã®ã‚‚ã®ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚

```rust
use procon_lib::MultiSet;

fn main() {
    let a = MultiSet::from(vec![1, 1, 2, 2, 3]);

    assert_eq!(a.upper_bound(std::ops::Bound::Excluded(&0)), None);
    assert_eq!(a.upper_bound(std::ops::Bound::Excluded(&2)), Some(&1));
    assert_eq!(a.upper_bound(std::ops::Bound::Included(&2)), Some(&2));
    assert_eq!(a.upper_bound(std::ops::Bound::Included(&4)), Some(&3));
}
```


## `marge`
ç‰‡æ–¹ã®`MultiSet`ã‚’ã‚‚ã†ç‰‡æ–¹ã«ãƒãƒ¼ã‚¸ã—ã¦ã€å’Œé›†åˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚
```rust
use procon_lib::MultiSet;

fn main() {
    let mut a = MultiSet::from(vec![1, 2, 3]);
    let mut b = MultiSet::from(vec![1, 1, 2, 3]);
    
    a.marge(&mut b);
    assert_eq!(a, MultiSet::from(vec![1, 1, 1, 2, 2, 3, 3]));
}
```


# ä½¿ç”¨ä¾‹

- [AtCoder Beginner Contest 308: F - Vouchers](https://atcoder.jp/contests/abc308/submissions/43210074)
- [AtCoder Beginner Contest 253: C - Max - Min Query](https://atcoder.jp/contests/abc253/submissions/43210678)
- [AtCoder Beginner Contest 170: E - Smart Infants](https://atcoder.jp/contests/abc170/submissions/43213745)